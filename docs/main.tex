\documentclass{article}
\usepackage{graphicx}

\title{Smart Bike}
\author{Group 7: Beñat Ramirez, Meritxell Carvajal Librado, \\ Vigo Matuka, Mark Suvorov}
\setlength{\parskip}{1em}
\date{}

\begin{document}

\maketitle
\section{Introduction}

The Smart Bike project will be implemented as an attachable device for the bike, which will expand your biking experience beyond just pedaling.

It will include features for automating routine tasks, such as locking and unlocking your bike every time you need to leave it for five minutes. It will also provide the lights that operate based on the surrounding light level, so when the evening comes they turn on automatically and contribute to your safety. Using both lights and sound, the Smart Bike device will make it easier to locate the bike in the parking area by signaling when the user needs it. Moreover, the heaters on the handles are activated either by the surrounding temperature or the user's request will make biking even more enjoyable.

Besides the features improving the comfort of using the bike, the project includes the mobile app, where the history of the rides will be recorded and displayed in a user-friendly format for informational purposes and to provide feedback to the user.

For the connection of the device to a network and the mobile app the wireless technologies will be used. The data transferred over these networks will be encrypted, ensuring privacy and security.

\noindent
The project implements the following functionalities:

\begin{enumerate}
\item \textbf{Collecting the data from:}
	\begin{itemize}
	\item Light sensor
	\item Temperature sensor
	\item GPS module
	\end{itemize}
\item \textbf{Data Processing:}
	\begin{itemize}
	\item Arranging the data from different sensors into the payloads to send over the network
	\item Local logic for manipulating actuators
	\end{itemize}
\item \textbf{Output Control:}
	\begin{itemize}
	\item Lock with remote control / proximity lock
	\item Automatic lights reacting to the environmental light levels 
	\item Sound and light control as part of the UI, also helping to find the bike in the parking area
	\item Heater elements on the handles of the bike
	\item Info and statistics displayed in the Android App
	\end{itemize}
\item \textbf{Additional functionality:}
	\begin{itemize}
	\item Wireless connectivity 
	\item Mobile app
	\item Security
	\end{itemize}
\end{enumerate}
For further development, the cloud integration can be considered, along with the analysis of anonymized user data for research purposes or to improve biking routes and infrastructure.

Furthermore, the idea of deeper integration of sensors and actuators directly into the bike, as opposed to the attachable version, can also be explored. At the very least, this could allow the inclusion of the sensors measuring the force on the pedals, which would contribute significantly to the usefulness of the statistics provided in the app. It could also include pressure sensors in the tires to track tire pressure and signal when it is too low.  

\section{Architecture}

\begin{figure}[h!]
	\includegraphics[width=\linewidth]{Slide1.jpg}
	\caption{Architecture diagram}
	\label{fig:architecture}
\end{figure}

In figure \ref{fig:architecture}, we can see the architecture that we will use for our project. In the IoT device, the Sensor/Actuator API
provides an abstraction that allows us to easily access to the data provided by different sensors or activate different
actuators in an easy way. The network manager will be in charge of handling the connectivity with the mobile app. The business
layer takes decisions based on the data from different sources.
\\
\\
In the mobile app we have a two layer architecture for the client: The presentation layer renders the UI for the user and the service proxy handles the connection to the IoT device, and is in charge of the data serialization.

\section{Methods \& Tools}
The development of the Smart Bike system is based on a modular architecture combining embedded programming on the Raspberry Pi Pico W, wireless communication, and a mobile application. The project follows an object-oriented programming (OOP) approach, where each hardware and software component is encapsulated into dedicated classes (e.g. LightSensor, ActuatorController, MQTTClient, AppInterface). 


\subsection{Tools on Frontend}

The frontend of the Smart Bike system was developed as an Android mobile application using Android Studio and the Kotlin programming language. The application serves as the primary user interface, enabling users to monitor sensor data, visualize ride history, and remotely control bike functionalities.

\subsubsection{UI Framework and Architecture}

The application is implemented using Jetpack Compose, Android’s modern declarative UI framework. This approach allows for a clear separation between the presentation layer and application logic, improving modularity and maintainability. The user interface is structured into independent composable screens:

\begin{itemize}
    \item \textbf{Home Screen:} Displays real-time sensor data such as temperature and ambient light level, and provides quick access to core controls including lock/unlock and light on/off.
    \item \textbf{Settings Screen:} Allows users to configure advanced features such as automatic light activation thresholds, proximity-based unlocking distance, language selection, and activation of the find mode.
    \item \textbf{Map Screen:} Presents historical GPS routes for selected dates, enabling users to review past rides with speed-based visual feedback.
\end{itemize}

Navigation between screens is managed through a bottom navigation bar, ensuring a consistent and intuitive user experience.

\subsubsection{State Management and Data Flow}

The frontend follows a ViewModel-based architecture, where application state—including sensor values, GPS history, and configuration settings—is exposed through observable state flows. This design ensures that the user interface automatically reacts to backend updates and user interactions without requiring manual refreshes.

User actions such as toggling lights, locking the bike, or submitting configuration settings immediately trigger network requests, while sensor data is periodically fetched and reflected in the UI in near real time.

\subsubsection{Networking and Backend Communication}

Communication between the Android application and the Smart Bike device is handled through a dedicated Service Proxy layer. This component abstracts network operations and provides a clean API for the UI and ViewModels.

The Service Proxy supports the following operations:
\begin{itemize}
    \item Retrieving live sensor data (temperature, light level)
    \item Sending control commands (lock, lights, find mode)
    \item Submitting configuration settings (auto-light thresholds, proximity lock distance)
    \item Fetching historical GPS data for route visualization
\end{itemize}

The networking stack is implemented using OkHttp3, a widely adopted and efficient HTTP client for Android. OkHttp3 is responsible for creating and managing HTTP connections, sending GET and PUT requests to the IoT device, handling JSON-based request and response payloads, and managing connection reuse and low-level network performance.

All data exchanged between the mobile application and the backend is encoded in JSON format. Network operations are executed asynchronously using Kotlin coroutines to ensure that communication with the IoT device does not block the main UI thread and that the application remains responsive.

\subsubsection{Data Visualization}

For ride history visualization, the application includes a custom map-style canvas implementation. GPS coordinates received from the backend are projected onto a two-dimensional plane and connected to form a continuous route. Speed information is represented using color-coded segments, allowing users to easily distinguish between slow, medium, and fast sections of a ride. Key points are highlighted and labelled to improve clarity.

This lightweight visualization approach avoids reliance on external mapping services while still providing meaningful insight into riding behaviour.

\subsection{Tools on Backend}

The backend of the system was implemented using MicroPython, a compact implementation of Python designed for devices with limited computational resources. MicroPython was chosen due to its low memory footprint and suitability for IoT environments, as well as its use of familiar Python syntax, which simplifies development and testing.

A central component of the backend is Micropyserver, a lightweight web server specifically designed for MicroPython. Micropyserver enables the microcontroller to receive and process HTTP requests and send appropriate responses. In this project, it was used to create web endpoints that allow external applications to retrieve sensor data and control system functionalities in real time. Its minimal design ensures efficient memory usage while maintaining reliable communication between the device and the client application.

The backend is organized into distinct modules responsible for sensor data acquisition, request handling, and data processing. This modular structure improves maintainability and scalability, as changes to one component can be made without affecting the rest of the system. Helper scripts are used for tasks such as data formatting and common operations, resulting in cleaner and less repetitive code.

Overall, the selected backend tools provide a balanced combination of performance, simplicity, and flexibility, enabling the system to operate reliably within the constraints of a resource-limited IoT environment.

\section{Evaluation}

\subsection{Evaluation planning}

To be able to ensure that the products performance is the expected, we will carry on different evaluation that will measure different
attributes of the product.
\\
\\
\textbf{Throughput:} The throughput of our product is not that critical, because just a couple of devices will be connected and sending messages to the device
at any point, it is not expected to receive a high volume of messages. But our product will have a minimum throughput of 10 messages per second, ensuring that
the user never has to wait for any message to be processed.
\\
\\
\textbf{Latency:} To have an adequate user experience, all the actions requested from the mobile app to the device should be answered and carried
out in less than 0.5 seconds.
\\
\\
\textbf{Usability:} Our product should be usable by any potential user with ease. Both the device and the mobile app should have an easy installation, setup and 
operation. To ensure that, the device must be able to be installed in the bike in less than 5 minutes by an unexperienced user, and the users should not take more
than 2 minutes to perform any task on the mobile app without previous knowledge.
\\
\\
To ensure that this criterion is met, we will carry out two evaluation scenarios:
\begin{itemize}
	\item A latency test, where we will send an instruction to the device and measure the time it takes to give a response.
	\item A usability test, where a user who has never used the app will be requested to perform a task and we will measure the time it takes.
\end{itemize}


\subsection{Evaluation results}

\subsubsection{Latency test:}

For this test we have used Locust, a python testing framework that allows us to simulate 
multiple clients doing requests to the device, and check how the device performs over load.
To more accurately represent the behavior of real scenarios, only one client is going to perform request
to the device. This client will do requests to three different endpoints: A test endpoint that always returns a text,
the find mode trigger endpoint and the sensor data endpoint.

\begin{figure}[h!]
	\includegraphics[width=\linewidth]{graph.png}
	\caption{Latency test results}
	\label{fig:performance}
\end{figure}

As we can see in figure \ref{fig:performance} 95\% of the requests have a latency of less than 250 milliseconds, beating our goal
of 0.5 second response time. The average latency has been of 199.3 milliseconds. Our device is also able to 
respond to 5 requests per second, which is enough for a single client doing requests to a single device, but does not match our expected 10 requests per second. 
The response time is also very similar between the three requests, indicating that the data processing doesn't take too
long in the device, and that the most time consuming part of the process is data serialization and transmission through the network. 

\subsubsection{Usability Tests}

Several usability tests were conducted to evaluate system effectiveness, ease of use, and overall user experience. The primary objective of these tests was to ensure that users could interact with the application naturally and complete essential tasks without confusion or unnecessary difficulty.

The first usability test focused on initial user interaction. Participants were asked to connect to the system and retrieve sensor data without receiving any prior instructions. Observations indicated that most users were able to complete this task independently, suggesting that the system’s interaction flow is clear and intuitive. Minor delays were observed during initial use, primarily due to unfamiliarity with the interface rather than design shortcomings.

The second test evaluated task efficiency and response clarity. Users were asked to request sensor data multiple times and interpret the returned information. Feedback showed that system responses were sufficiently fast and that the data presentation was easy to understand. Participants reported confidence in interpreting the received values, indicating that the system’s data output is well-structured and consistent.

The final usability test examined error handling and system feedback. Users intentionally performed incorrect actions, such as requesting unavailable resources or disconnecting during data transmission. In these cases, the system provided clear and informative feedback messages, enabling users to understand the issue and recover without external assistance. This demonstrates effective error handling and user guidance.

\section{Results}
The usability evaluation showed that most users were able to complete essential tasks without assistance, indicating a low learning curve. Interaction times improved after brief use, suggesting quick user adaptation.

System responses were perceived as reliable, and participants demonstrated clear understanding of the presented data. Error scenarios were handled effectively, with users able to recover independently based on system feedback.

Overall, the results confirm that the system provides a stable and user-friendly experience for users with varying technical backgrounds.

\section{Discussion}
According to the evaluation, the application successfully passed the prepared tests. The technical component is stable and operates reliably. The communication tests produced very good results, which would meet the requirements of a potential final product while still leaving additional resources available.

The usability tests also showed satisfactory results; however, due to the limited sample size, they may not be fully representative. The user interface is still in an early prototype phase, and some elements require further refinement to ensure an improved user experience.

Referring back to the functionality planned at the start of the project, it can be stated that the project met most of the initial expectations. Several features were implemented in a manner very close to the original vision, such as the “find mode,” automatic lighting, light control, and wireless connectivity.

Some features remain in a prototype stage due to the lack of hardware required for their full implementation. Examples include the locking functionality and all GPS-related features. Nevertheless, the software component of the system was designed with real hardware integration in mind, meaning that integration would not be overly complex and would require only minor code modifications. Additionally, there was insufficient time to implement certain features, specifically the heaters and their control mechanisms, as well as the security layer for networking and data storage.

In conclusion, the project met most of its initial goals and delivered a stable and well-functioning system. Despite certain limitations related to hardware availability and development time, the results indicate that the project has strong potential for further development.

\end{document}


